# 최적화는 신중히 하라.

## 최적화의 명언 세가지
 > 그 어떤 핑계보다 효율성이라는 이름 아래 행해진 컴퓨팅 죄악이 더 많다. (효율을 높이지도 못하면서)  
 > -윌리엄 울프-

 > 전체의 97% 정도인 자그마한 효율성은 잊어라. 섣부른 최적화가 만악의 근원이다.  
 > -도널드 크누스-

 > 1. 최적화 하지마라.
 > 1. 전문가 한정 아직 하지마라. 성능을 낮추는 부분과 개선할 최적화가 명백해질 때까지 미뤄라.   
>  
 > -M. A. Jackson-

최적화는 해로운 결과로 이어지기 쉽다.  
빠르지도 않고 재대로 동작하지도 않으면서, 수정하기는 어려운 소프트웨어를 만들기 쉽다.

## 빠른 프로그램보다는 좋은 프로그램을 작성하자.
 - 성능 때문에 견고한 구조를 희생시키지 말라.
 - 좋은 프로그램을 짰다면, 시스템의 다른 부분을 변경하지 않고 문제되는 부분만 독립적으로 수정, 설계할 수 있다.
 - 구현상의 문제는 나중에 최적화하여 해결할 수 있지만, 아키텍쳐의 결함이 성능을 제한하면 시스템 전체를 재작성해야한다.
 - 시스템 전체를 재작성하는 행위는 프로그램을 유지보수하기 힘들게, 수정하기 힘들게, 꼬인구조의 프로그램을 만들어서 좋지 않다.
 
## 성능을 제한하는 설계를 피하라.
 - 아래의 설계는 완성 후 변경하기가 가장 어려운 설계요소이다.
    - 컴포넌트끼리, 혹은 외부 시스템과의 소통
    - API, 네트워크 프로토콜, 영구 저장용 데이터 포맷
 - 이 요소들은 완성 후에는 변경하기 매우 어렵다. 따라서 설계단계에서 성능을 염두에 두어야한다.
 
## 성능에 영향을 주는 설계의 예 : API 설계에서의 예
 - 만약 Public 타입을 가변으로 만들었다면, 매번 방어적 복사를 하며 성능에 악영향을 끼칠 수 있다.
 - 만약 컴포지션이 가능한 부분을 상속으로 처리했다면, 하위 클래스는 상위 클래스에 영원히 종속된다. 하위 클래스는 상위 클래스의 성능제약도 상속받는다.
 - 만약 인터페이스 타입이 아닌 구현 타입을 사용하면, 다른 더 나은 성능의 구현체로 바꿀 수 없게된다.
 
 
#### 따라서 ! 
 - 성능을 위해 API 를 수정, 왜곡하는 것은 좋지 않은 선택이다.
 - 좋은 설계는 보통 좋은 성능을 가져온다.
 - 만약 성능이 떨어져도, 좋은 설계를 했다면 성능 최적화를 깔끔하게 할 수 있다.
 - 그렇기 때문에, 신중한 설계로 꺠끗하고 명확한 구조의 프로그램이 완성된 후에야 최적화를 고려 할 수 있다.
 
## 각각의 최적화 시도 전후로 성능을 측정하라.
 - 이책의 앞부분에도 종종 언급되었다.
 - 우리는 프로그램에서 시간을 잡아먹는 부분을 예측하기 어렵다.
 - 성능 문제가 있을 것이라 생각한 곳이 아무 문제가 없을 수 도 있다. 그런 부분을 고쳤다면 오히려 성능이 나빠질 수 도 있다.
 - 일반적으로 90 % 의 시간을 잡아먹는 코드는 전체의 10 % 이다.
 - 따라서, 최적화 시도 전후로 꼼꼼한 성능 측정을 통해 그 최적화가 적절한 것인가, 사용할 것인가에 대한 검증을 꼼꼼히 해야한다.
 
#### 최적화를 도와주는 도구 : 프로파일링 도구
 - 개별 메서드의 소비 시간과 호출 횟수 같은 런타임정보를 제공한다.
 - 최적화 노력을 어디에 집중해야할 지 알려줄 수 있다.
 - 어떤 알고리즘을 바꿔야하는지 알려줄 수 있다.
 - 시스템이 커질수록 이 도구의 효율성은 높아진다.
 - jmh (마이크로 벤치마킹 프레임워크) 또한 자바 코드의 상세 성능을 알려주는 유용한 도구다. (프로파일러는 아니지만.)
 
 
## 최적화의 순서
 1. 신중한 설계로 좋은 프로그램을 설계한다.
    - 하지만 성능을 염두에 두고 설계한다.
 1. 구현을 완료하면 성능을 측정한다.
 1. 성능이 부족하다면, 프로파일러로 문제 부분을 찾아 최적화를 한다.
 1. 최적화의 효과가 있는지 성능을 다시 측정한다.
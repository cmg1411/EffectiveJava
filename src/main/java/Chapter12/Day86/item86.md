# Serializable 을 구현할지는 신중히 결정하라.

Serializable 을 클래스 선언에서 implements 하면, 인스턴스를 직렬화할 수 있게 된다.

## Serializable 을 구현하면 ?

#### 릴리즈 후에는 수정하기 어렵다.
 - 직렬화된 바이트 스트림 인코딩도 나의 공개 API 가 된다.
 - 커스텀 직렬화 형태를 구현하지 않고, 기본 자바 직렬화를 사용하면 직렬화 형태는 내부 구현에 묶인다.
 - private 든, package-private 든 클래스의 인스턴스 필드마저 공개 API 로 노출된다. (캡슐화가 깨진다는 것도 있는 것이다.)
 - 깨진 캡슐화를 고치려 내부 구현을 바꾸면 또 문제다.
 - 한 쪽은 구버전 인스턴스를 직렬화하고, 한쪽은 신버전 클래스로 역직렬화하면 실패하기 때문이다.
    
예를 들어 직렬화의 고유 식별자 serialVersionUID 는 개부의 클래스 이름, 구현한 인터페이스 등 대부분의 클래스 멤버를 이용하여 생성하는데, 내부 구현을 조금이라도
바꾸면 이 값이 변할 것이고 호환성이 깨져 InvalidClassException 을 보게 된다.

#### 버그와 보안 구멍이 생길 위험이 높아진다.
 - 언어의 기본 메커니즘을 우회하는 객체 생성이다.

#### 해당 클래스의 신버전을 릴리즈할 때 테스트할 것이 늘어난다.
 - 신버전 인스턴스를 직렬화 한 후 구버전으로 역직렬화할 수 있는지와 반대도 테스트를 매번 해야한다.
 - 커스텀 직렬화 형태를 잘 설계해놓으면 이 테스트 부담을 덜 수 있다.  
 
 
## 구현의 선택
 - 역사적으로 다음의 선택을 했다.
    - 값 클래스, 컬렉션 클래스 : 구현 (BigInteger, Instant ... )
    - 동작 클래스 : 구현하지 않음.
 - 상속용 클래스, 인터페이스는 Serializable 구현하지 않음.
    - 하위 클래스들에게 모두 부담을 지우게 된다. 필요한 곳에만 하면 될 것을..
    - 물론 하위 클래스들에서 부담이 늘어난다. 이 클래스들을 역직렬화 할 때는 보통 상위 클래스에서 기본 생성자를 제공해야 하며, 기본 생성자를 제공하지 못한다면, 직렬화 프록시 패턴을 사용한다.
 - 상속가능 클래스에서 직렬화를 지원하겠다면, 아래를 준수하라.
    - 하위 클래스에서 finalize 메서드를 재정의하지 못하게 하라.
        - 자신이 재정의하면서 final 을 붙이면 된다.
    - 인스턴스 필드 중 기본값 (정수 = 0, boolean = false, 객체 = null) 로 초기화하면 불변식이 꺠지는 경우는 readObjectNoData 메서드를 추가한다.
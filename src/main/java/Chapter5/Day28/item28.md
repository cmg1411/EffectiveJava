# 배열보다는 리스트를 사용하라.

## 배열과 제네릭 타입의 차이
 - 공변
 1. 배열
    1. Sub 가 Super 의 하위타입이라면 Sub[] 도 Super[] 의 하위타입.
 1. 리스트
    1. Type1, Type2 가 있을때, List<Type1> 읜 List<Type2> 의 상위타입도 하위타입도 아님.
    
 <br>
 
 - 실체화
 1. 배열
    1. 실체화가 됨 : 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인함.  
 1. 리스트
    1. 제네릭은 런타임에 타입정보가 소거. 때문에 원소 타입을 **컴파일타임 에만 검사**
    1. 따라서 타입을 명시적으로 케스팅해주고 해야함.
    
    
    
#### 실체화 불가 타입
 - E, List<E>, List<String> ..
 - 실체화 되지 않아서 런타임에는 컴파일타임보다 타입 정보를 적게 가지는 타입
 - 제네릭 하위 호환성 떄문에 소거 메커니즘이 있기 때문에.
 - 비한정적 와일드카드 <?>, <?, ?> 만이 실체화 가능
 - 자신의 원소 타입을 담은 배열을 반환하는 게 보통은 불가능하다.
 - 제네릭 타입을 가변인수에 쓸 수 없는데, 가변인수는 내부적으로 배열을 생성하기 때문이다. 배열의 요소가 실체화 불가 타입이면 경고가 발생한다.
 
 
 
 ## 결론
배열 타입은 실체화가 가능하기 때문에 런타임에 오류가 난다. 그리고 공변이기 때문에 컴파일타임에 오류를 잡지 못한다.  
제네릭 리스트는 실체화가 불가하기 때문에 런타임에는 오류를 잡지 못한다. 불공변이기 때문에 컴파일타임에 오류를 잡을 수 있다.  

**컴파일타임에 오류를 내는 것이 더 좋으므로 리스트를 써라!!**
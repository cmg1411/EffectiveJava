## equals 를 재정의하려든 hashCode 도 재정의하라.

### 그렇지 않으면, hashCode() 를 사용하는 hashMap, hashSet 등에서 문제를 일으킬 것이다 !!

 <br>

#### Object 명세 규약
 1. equals 에서 비교하는 정보가 변경되지 않는 한, 애플리케이션이 실행되는 동안 hashCode 의 값은 변하지 않음.
 프로그램이 다시 실행됬을 때에는 다른 값일 수 있다.
 1. equals 가 두 객체가 같다고 판단했다면, 두 객체의 hashCode 값은 프로그램이 실행되는 동안 같다.
 1. equals 가 다르다고 판별했다고 hashCode 도 다를 필요는 없다. 단, 다른 객체에 대해서는 다른 hashCode 값을 반환해야 hashTable 성능이 좋다.
 (해시충돌)
 
 여기서 해시코드를 잘못 재정의 하면 문제가 되는 항목은 두번째다.
 
 equals 메소드는 물리적으로는 다르지만 논리적으로는 같다고 재정의할 수 있다.
 하지만 hashCode 가 재정의되지 않았다면, hashCode 는 다른 값을 반환하여 다른 객체로 판단할 것이다.
 
 <br>
 
#### 좋은 hashCode 메서드를 작성하는 요령
 1. int 변수 result 를 선언한 후 값 하나의 핵심 필드를 이용해 만든 c 로 초기화한다.  
 c는 equals 메서드에서 사용한 핵심 필드를 이용하여 2번의 방식을 거쳐 생성된 값이다.  
 int result = c;
 
 2. 나머지 핵심 필드 f 를 이용하여 c 를 구한다.
   - 해당 필드의 해시코드 c 를 계산한다.
     - 기본 타입 필드 : Type.hashCode(f)
     - 참조 타입 필드 && equals 메소드가 이 필드의 equals() 를 재귀적으로 호출 : hashCode 를 재귀적으로 호출, 필드값이 null 이면 0 사용
     - 배열 필드 : 핵심 원소 각각을 필드처럼 다뤄서 위의 과정 수행. 모든 원소가 핵심 필드라면, Arrays.hashCode() 사용 가능.
   - 위의 계산 값 c 로 result 를 갱신한다.
     ```
      result = 31 * result + c;
     ```
     
 마지막. result 를 반환한다.

<br>
<br>
31 * result 는 필드를 곱하는 순서에 따라 결과를 다르게 만든다.

이것이 아니라면 아나그램이 모두 같은 값을 반환할 것이다.  
31 을 쓰는 이유는 소수이며 홀수이기 때문이다. 짝수는 2의 곱이기 때문에 비트연산으로 자릿수가 올라가며, 오버플로가 일어날 수 있다.

#### 좋은 hashCode 의 조건
 - **핵심** 필드 만 hashCode 에 사용  
 - 파생 필드는 사용안함  
 - equals 에 사용되지 않은 필드는 **사용하면 안됨**
 
 
#### 팁
클래스가 불변이고 해시코드를 계산하는 비용이 크다면,
private int hashCode; 를 선언해놓고 캐싱하여 사용할 수 있도록 한다.
이 때, hashCode 의 초깃값은 일반적으로 생성되는 해시코드값과 다른 값을 가지도록 한다. (보통 0)
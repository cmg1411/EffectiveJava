package Day19;

public class Main {

    // 5. 상속용 클래스의 생성자는 재정의 가능 메서드를 호출해서는 안된다. 직접적으로든 간접적으로든.
    Main() {
        method();
    }

    /**
     * 1. 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.
     * @implSpec 이용
     * 2. 클래스의 내부 동작 과정에 끼어들 수 있는 훅을 잘 선별하여 protected 메서드 형태로 공개해야 할 수 있다.
     * 클라이언트가 직접적으로 사용하지는 않지만, public 메서드를 재정의할 때 쓰일 수 있는 메서드들을 말한다.
     * 3. 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 생성하는 것 말고는 없다.
     * 4. 상속용을 ㅗ설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.
     *
     *
     * 5. 상속용 클래스의 생성자는 재정의 가능 메서드를 호출해서는 안된다. 직접적으로든 간접적으로든.
     *
     * 6. 생성자, clone, readObject 는 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.
     *
     * 7. final 클래스로 만들어서 상속을 금지하거나, 모든 생성자를 private 으로 만들고, 정적 팩터리 메서드로 객체를 제공하여 상속을 금지할 수 있다.
     * @param
     * @implSpec
     */


    public void method() {
        System.out.println("Not Override");
    }
}
